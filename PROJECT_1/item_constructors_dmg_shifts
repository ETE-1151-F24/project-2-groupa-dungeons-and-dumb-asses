// item_constructors_dmg_shifts.cpp

#include "GameHeaderEli.h"
#include <cstdlib>                       // Required for random number generation
#include <ctime>                         // Required for seeding the random number generator

// Default constructor for Item
Item::Item() : name(""), description(""), ability(""), classification(MAGICAL), combatType(MELEE),
               minDamage(0), maxDamage(0), rangeModifier(0), sneakPenalty(0), restriction("") {
    // Initialize all stat modifiers to 0
    for (int i = 0; i < StatCount; ++i) {
        statModifier[i] = 0;
    }
}

// Parameterized constructor for Item
Item::Item(std::string itemName, std::string itemDescription, ItemType itemClassification,
           CombatType itemCombatType, std::array<int, StatCount> modifier, std::string itemAbility,
           int minDmg, int maxDmg, int rangeMod, int sneakPen, std::string itemRestriction)
    : name(itemName), description(itemDescription), classification(itemClassification),
      combatType(itemCombatType), ability(itemAbility), minDamage(minDmg), maxDamage(maxDmg),
      rangeModifier(rangeMod), sneakPenalty(sneakPen), restriction(itemRestriction) {

    // Initialize stat modifiers from the provided array
    for (int i = 0; i < StatCount; ++i) {
        statModifier[i] = modifier[i];
    }
}

// Function to calculate damage based on combat type
int Item::calculateDamage(int distance) {
    if (combatType == RANGED) {
        return calculateRangedDamage(distance, rangeModifier, minDamage, maxDamage); // Call ranged damage calculation
    } else if (combatType == MELEE) {
        return calculateMeleeDamage();                                               // Call melee damage calculation
    }
    return 0;                                                                        // Default return if combat type is not applicable
}

// Private function to calculate damage for ranged weapons based on distance
int Item::calculateRangedDamage(int distance, int maxRange, int minDamage, int maxDamage) {
    // Seed the random generator (only needed once in the game initialization)
    static bool seeded = false;                     // Static variable to track if the generator has been seeded
    if (!seeded) {
        std::srand(std::time(0));                   // Seed the random number generator with the current time
        seeded = true;                              // Mark that the generator has been seeded
    }

    int damage = 0;                                 // Initialize damage to 0

    if (distance == 1) {
        damage = std::max((std::rand() % (maxDamage - minDamage + 1)) + minDamage - 1, 1); // Reduce min and max by 1, ensure minimum is 1
    } else if (distance <= maxRange) {
        damage = (std::rand() % (maxDamage - minDamage + 1)) + minDamage; // Roll damage within normal range
    } else {
        damage = (std::rand() % (maxDamage - minDamage + 1)) + minDamage; // Start with damage within normal range
        damage -= (distance - maxRange);                                  // Reduce damage for each square beyond max range
        damage = std::max(damage, 1);                                     // Ensure minimum damage of 1
    }

    return damage;                                                        // Return calculated damage
}

// Private function to calculate damage for melee weapons (simplified logic)
int Item::calculateMeleeDamage() {
    // Seed the random generator (only needed once in the game initialization)
    static bool seeded = false;                     // Static variable to track if the generator has been seeded
    if (!seeded) {
        std::srand(std::time(0));                   // Seed the random number generator with the current time
        seeded = true;                              // Mark that the generator has been seeded
    }

    // Simple melee damage calculation between minDamage and maxDamage
    return (std::rand() % (maxDamage - minDamage + 1)) + minDamage; // Roll damage within min and max range
}